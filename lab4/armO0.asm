fact:
    push    {r7, lr}      ; Сохраняем регистры r7 и lr в стеке
    vpush.64 {d8}         ; Сохраняем двойное слово d8 в стеке
    sub     sp, sp, #8     ; Резервируем 8 байт на стеке
    add     r7, sp, #0     ; r7 указывает на текущую вершину стека
    str     r0, [r7, #4]   ; Сохраняем r0 (аргумент N) на стеке
    ldr     r3, [r7, #4]   ; Загружаем N в r3
    cmp     r3, #0         ; Сравниваем N с 0
    bge     .L2            ; Если N >= 0, переходим к метке .L2
    vldr.64 d7, .L5         ; Загружаем константу в d7
    b       .L3            ; Переходим к метке .L3
.L2:
    ldr     r3, [r7, #4]   ; Загружаем N в r3
    cmp     r3, #0         ; Сравниваем N с 0
    bne     .L4            ; Если N != 0, переходим к метке .L4
    vmov.f64 d7, #1.0e+0    ; Загружаем 1.0 в d7
    b       .L3            ; Переходим к метке .L3
.L4:
    ldr     r3, [r7, #4]   ; Загружаем N в r3
    vmov    s15, r3 ; int   ; Перемещаем N в одинарную точность в s15
    vcvt.f64.s32 d8, s15    ; Преобразуем s15 в двойную точность и сохраняем в d8
    ldr     r3, [r7, #4]   ; Загружаем N в r3
    subs    r3, r3, #1      ; Уменьшаем N на 1
    mov     r0, r3          ; Передаем N - 1 в r0
    bl      fact            ; Рекурсивный вызов функции fact
    vmov.f64 d7, d0          ; Загружаем результат в d7
    vmul.f64 d7, d8, d7     ; Выполняем умножение d8 и d7
.L3:
    vmov.f64 d0, d7          ; Результат сохраняется в d0
    adds    r7, r7, #8       ; Освобождаем 8 байт на стеке
    mov     sp, r7           ; Восстанавливаем указатель стека
    vldm    sp!, {d8}        ; Восстанавливаем значение d8 из стека
    pop     {r7, pc}         ; Восстанавливаем r7 и возвращаемся
.L5:
    .word   0
    .word   0
.LC0:
        .ascii  "%Le \000"
main:
    push    {r7, lr}         ; Сохраняем регистры r7 и lr в стеке
    sub     sp, sp, #48      ; Резервируем 48 байт на стеке
    add     r7, sp, #0       ; r7 указывает на текущую вершину стека
    mov     r2, #0           ; Инициализируем r2 (нужно для объявления длинного числа)
    mov     r3, #0           ; Инициализируем r3 (нужно для объявления длинного числа)
    strd    r2, [r7, #40]    ; Сохраняем пару 64-битных нулей в стеке
    mov     r2, #0           ; Сбрасываем r2
    mov     r3, #1073741824  ; Устанавливаем r3 (для инициализации x в C)
    strd    r2, [r7, #24]    ; Сохраняем пару 64-битных значений в стеке
    movs    r3, #100         ; Устанавливаем r3 (для n)
    str     r3, [r7, #20]    ; Сохраняем n в стеке
    movs    r3, #0           ; Сбрасываем r3
    str     r3, [r7, #36]    ; Сбрасываем r3 (для счетчика цикла)
    b       .L8              ; Переходим к метке .L8
.L9:
    ldr     r3, [r7, #36]    ; Загружаем счетчик цикла в r3
    vmov    s15, r3 ; int   ; Перемещаем r3 в одинарную точность в s15
    vcvt.f64.s32 d7, s15    ; Преобразуем s15 в двойную точность и сохраняем в d7
    vmov.f64 d1, d7         ; Копируем d7 в d1
    vldr.64 d0, [r7, #24]   ; Загружаем значение x в d0
    bl      pow             ; Вызываем функцию pow
    vstr.64 d0, [r7, #8]    ; Сохраняем результат в d0
    ldr     r0, [r7, #36]    ; Загружаем счетчик цикла в r0
    bl      fact            ; Вызываем функцию fact
    vstr.64 d0, [r7]        ; Сохраняем результат в стеке
    vldr.64 d5, [r7, #8]    ; Загружаем значение из стека в d5
    vldr.64 d6, [r7]        ; Загружаем значение из стека в d6
    vdiv.f64 d7, d5, d6     ; Выполняем деление d5 на d6
    vldr.64 d6, [r7, #40]   ; Загружаем значение из стека в d6
    vadd.f64 d7, d6, d7     ; Выполняем сложение d6 и d7
    vstr.64 d7, [r7, #40]   ; Сохраняем результат в стеке
    ldr     r3, [r7, #36]    ; Загружаем счетчик цикла в r3
    adds    r3, r3, #1       ; Увеличиваем счетчик на 1
    str     r3, [r7, #36]    ; Сохраняем счетчик цикла в стеке
.L8:
    ldr     r3, [r7, #20]    ; Загружаем n в r3
    adds    r2, r3, #1       ; Увеличиваем r2 на 1
    ldr     r3, [r7, #36]    ; Загружаем счетчик цикла в r3
    cmp     r2, r3           ; Сравниваем r2 и счетчик цикла
    bhi     .L9              ; Если r2 > r3, переходим к метке .L9
    ldrd    r2, [r7, #40]    ; Загружаем пару 64-битных значений из стека
    movw    r0, #:lower16:.LC0  ; Загружаем адрес форматной строки в r0 (для printf)
    movt    r0, #:upper16:.LC0
    bl      printf           ; Вызываем функцию printf
    movs    r3, #0           ; Сбрасываем r3
    mov     r0, r3           ; Загружаем 0 в r0 (для возврата)
    adds    r7, r7, #48      ; Освобождаем 48 байт на стеке
    mov     sp, r7           ; Восстанавливаем указатель стека
    pop     {r7, pc}         ; Восстанавливаем r7 и возвращаемся

    ; в отличие от х86 арм команды имеют фиксированное количество байт 
    ; r13(sp) аналог esp, r11(fp) аналог ebp, r0-r3(a1-a4) - для аргументов, передача парам в функ, возврат из функ, 
    ; r4-r11(v1-v8) - для переменных
    ; если не хватает a1-а4, то аргументы передаются через стек
    ; если есть суффикс s, то команда устанавливает флаг

    ; add r1 r2 r3 lsl #2 складывается r2 r3, но r3 сдвигается на 2 бита влево, результта кладется в r1
    ; в arm можно только записывать и считыать - есть всего две команды ldr str

    ; [raddr, #4] = [raddr + 4]
    ; [raddr, #4]! = [raddr] raddr += 4
    ; [raddr], #4 = raddr += 4 [raddr]
    ; ldm/stm Rn!{regs} rn не включается в regs, без ! включается
    ; push - частный случай обращения в мамять

    ; bl - частынй случай перехода
    ; при вызове bl происходит переход, адрес следующей команды сохраняется в rl
    