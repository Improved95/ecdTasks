fact:
    push    {r3, lr}         ; Сохранение регистров r3 и lr на стеке
    cmp     r0, #0           ; Сравнение аргумента N с 0
    vpush.64 {d8, d9}        ; Сохранение регистров d8 и d9 на стеке
    blt     .L4              ; Если N меньше 0, переход к .L4
    bne     .L11             ; Если N не равно 0, переход к .L11
    vmov.f64 d8, #1.0e+0      ; Загрузка 1.0 в d8 (результат факториала)
.L1:
    vmov.f64 d0, d8           ; Загрузка результата в d0
    vldm    sp!, {d8-d9}      ; Восстановление регистров d8 и d9 с стека
    pop     {r3, pc}           ; Восстановление регистров r3 и pc (возврат)
.L11:
    vmov    s15, r0 ; int      ; Загрузка N в s15 (одинарная точность)
    subs    r3, r0, #1         ; Уменьшение N на 1 и сохранение в r3
    vcvt.f64.s32    d8, s15    ; Преобразование s15 в d8 (двойная точность)
    beq     .L1                ; Если N стало 0, вернуться к .L1
    vmov    s15, r3 ; int      ; Загрузка (N-1) в s15
    subs    r0, r0, #2         ; Уменьшение N на 2
    vcvt.f64.s32    d9, s15    ; Преобразование (N-1) в d9 (двойная точность)
    bl      fact               ; Рекурсивный вызов функции fact
    vmul.f64 d9, d9, d0        ; Умножение d9 на результат и сохранение в d9
    vmul.f64 d8, d8, d9        ; Умножение d8 на d9 и сохранение в d8
    b       .L1                ; Переход к .L1
.L4:
    vldr.64 d8, .L12           ; Загрузка значения из .L12 (0.0) в d8
    vmov.f64        d0, d8
    vldm    sp!, {d8-d9}
    pop     {r3, pc}
.L12:
    .word   0
    .word   0
.LC0:
    .ascii  "%Le \000"
main:
    push    {r3, r4, r5, r6, r7, lr}    ; Сохранение регистров r3, r4, r5, r6, r7, lr на стеке
    mvn     r7, #2             ; Инвертирование r7 (r7 = -2)
    mvn     r6, #1             ; Инвертирование r6 (r6 = -1)
    vpush.64 {d8, d9, d10, d11, d12, d13}  ; Сохранение регистров d8-d13 на стеке
    mov     r5, #-1            ; Инициализация r5 (r5 = -1)
    movs    r4, #0             ; Инициализация r4 (счетчик)
    vldr.64 d9, .L53
.L27:
    vmov    s15, r4 ; int      ; Загрузка счетчика r4 в s15 (одинарная точность)
    vmov.f64        d0, #2.0e+0  ; Загрузка 2.0 в d0
    vcvt.f64.s32    d8, s15    ; Преобразование s15 в d8 (двойная точность)
    vmov.f64        d1, d8     ; Копирование d8 в d1
    bl      pow               ; Вызов функции pow
    vmov.f64        d6, d0     ; Сохранение результата в d6
    cbnz    r4, .L15          ; Если r4 не равен 0, переход к .L15
    vadd.f64        d9, d9, d0  ; Добавление d0 к d9
    adds    r5, r5, #1        ; Увеличение r5 на 1
    adds    r6, r6, #1        ; Увеличение r6 на 1
    adds    r7, r7, #1        ; Увеличение r7 на 1
    movs    r4, #1            ; Установка r4 в 1
    b       .L27
.L15:
    cbnz    r5, .L44            ; Если r5 не равен 0, переход к .L44
.L17:
    vdiv.f64        d7, d6, d8    ; Деление d6 на d8 и сохранение в d7
    adds    r4, r4, #1          ; Увеличение r4 на 1
    adds    r5, r5, #1          ; Увеличение r5 на 1
    adds    r6, r6, #1          ; Увеличение r6 на 1
    adds    r7, r7, #1          ; Увеличение r7 на 1
    cmp     r4, #101            ; Сравнение r4 с 101
    vadd.f64        d9, d9, d7    ; Добавление d7 к d9
    bne     .L27                ; Если r4 != 101, вернуться к .L27
    vmov    r2, r3, d9         ; Загрузка d9 в r2, r3 (результат)
    movw    r0, #:lower16:.LC0  ; Загрузка формата строки
    movt    r0, #:upper16:.LC0  ; Загрузка формата строки
    bl      printf              ; Вывод результата
    movs    r0, #0             ; Установка r0 в 0 (завершение программы)
    vldm    sp!, {d8-d13}       ; Восстановление регистров d8-d13
    pop     {r3, r4, r5, r6, r7, pc}  ; Восстановление регистров r3, r4, r5, r6, r7 и pc
.L44:
    vmov    s15, r5 ; int      ; Загрузка r5 в s15 (одинарная точность)
    vcvt.f64.s32    d5, s15    ; Преобразование s15 в d5 (двойная точность)
    cbnz    r6, .L45           ; Если r6 не равен 0, переход к .L45
.L18:
    vmul.f64        d8, d8, d5    ; Умножение d8 на d5
    b       .L17                ; Переход к .L17
.L45:
    vmov    s15, r6 ; int      ; Загрузка r6 в s15 (одинарная точность)
    vcvt.f64.s32    d4, s15    ; Преобразование s15 в d4 (двойная точность)
    cbnz    r7, .L46           ; Если r7 не равен 0, переход к .L46
.L19:
    vmul.f64        d5, d5, d4    ; Умножение d5 на d4
    b       .L18                ; Переход к .L18
.L46:
    vmov    s15, r7 ; int      ; Загрузка r7 в s15 (одинарная точность)
    subs    r3, r4, #4         ; Вычисление (r4 - 4) и сохранение в r3
    vcvt.f64.s32    d3, s15    ; Преобразование s15 в d3 (двойная точность)
    bne     .L47                ; Если r3 не равен 0, переход к .L47
    vmov.f64        d13, #1.0e+0
.L20:
    vmul.f64        d3, d3, d13  ; Умножение d3 на d13
    vmul.f64        d4, d4, d3   ; Умножение d4 на d3
    b       .L19                ; Переход к .L19
.L47:
    vmov    s15, r3 ; int      ; Загрузка r3 в s15 (одинарная точность)
    subs    r3, r4, #5         ; Вычисление (r4 - 5) и сохранение в r3
    vcvt.f64.s32    d13, s15   ; Преобразование s15 в d13 (двойная точность)
    bne     .L48                ; Если r3 не равен 0, переход к .L48
    vmov.f64        d12, #1.0e+0
.L21:
    vmul.f64        d13, d13, d12  ; Умножение d13 на d12
    b       .L20                ; Переход к .L20
.L48:
    vmov    s15, r3 ; int      ; Загрузка r3 в s15 (одинарная точность)
    subs    r3, r4, #6         ; Вычисление (r4 - 6) и сохранение в r3
    vmov    s4, r3  ; int      ; Копирование r3 в s4
    vcvt.f64.s32    d12, s15   ; Преобразование s15 в d12 (двойная точность)
    bne     .L49                ; Если r3 не равен 0, переход к .L49
    vmov.f64        d2, #1.0e+0
.L22:
    vmul.f64        d12, d12, d2  ; Умножение d12 на d2
    b       .L21                ; Переход к .L21
.L49:
    subs    r3, r4, #7         ; Вычисление (r4 - 7) и сохранение в r3
    vcvt.f64.s32    d2, s4     ; Преобразование s4 в d2
    vmov    s2, r3  ; int      ; Копирование r3 в s2
    bne     .L50                ; Если r3 не равен 0, переход к .L50
    vmov.f64        d1, #1.0e+0
.L23:
    vmul.f64        d2, d2, d1   ; Умножение d2 на d1
    b       .L22                ; Переход к .L22
.L50:
    subs    r3, r4, #8         ; Вычисление (r4 - 8) и сохранение в r3
    vcvt.f64.s32    d1, s2     ; Преобразование s2 в d1
    vmov    s20, r3 ; int      ; Загрузка r3 в s20 (одинарная точность)
    bne     .L51                ; Если r3 не равен 0, переход к .L51
    vmov.f64        d10, #1.0e+0
.L24:
    vmul.f64        d1, d1, d10  ; Умножение d1 на d10
    b       .L23                ; Переход к .L23
.L51:
    subs    r3, r4, #9         ; Вычисление (r4 - 9) и сохранение в r3
    vcvt.f64.s32    d10, s20  ; Преобразование s20 в d10 (двойная точность)
    vmov    s22, r3 ; int      ; Загрузка r3 в s22 (одинарная точность)
    bne     .L52                ; Если r3 не равен 0, переход к .L52
    vmov.f64        d11, #1.0e+0
.L25:
    vmul.f64        d10, d10, d11  ; Умножение d10 на d11
    b       .L24                ; Переход к .L24
.L52:
    vcvt.f64.s32    d11, s22   ; Преобразование s22 в d11 (двойная точность)
    sub     r0, r4, #10        ; Вычисление (r4 - 10) и сохранение в r0
    bl      fact               ; Вызов функции fact
    vmul.f64        d11, d11, d0  ; Умножение d11 на результат fact
    b       .L25                ; Переход к .L25
.L53:
        .word   0
        .word   0