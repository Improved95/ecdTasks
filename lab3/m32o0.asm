swap:
        pushl   %ebp ; Старое значение регистра %ebp (Base Pointer) сохраняется на стеке, чтобы можно было его восстановить перед выходом из функции.
        movl    %esp, %ebp ; Текущее значение регистра %esp (Stack Pointer) копируется в регистр %ebp, устанавливая его в качестве базового указателя для локальных переменных и параметров функции.
        subl    $16, %esp ; Резервируется на стеке место для локальных переменных и других данных размером 16 байт.
        movl    8(%ebp), %eax ; Значение, находящееся по адресу 8(%ebp), загружается в регистр %eax. Это будет первый аргумент функции swap, обычно указатель на int a.
        movl    (%eax), %eax ; Значение, на которое указывает %eax, загружается обратно в %eax. Это значение a из адреса, на который указывает указатель
        movl    %eax, -4(%ebp) ; Значение в %eax сохраняется в локальной переменной, которая находится по адресу -4(%ebp). Это переменная int c
        movl    12(%ebp), %eax ; Значение, находящееся по адресу 12(%ebp), загружается в регистр %eax. Это будет второй аргумент функции swap, обычно указатель на int b
        movl    (%eax), %edx ; Значение, на которое указывает %eax, загружается в регистр %edx. Это значение b из адреса, на который указывает указатель.
        movl    8(%ebp), %eax ; Значение, находящееся по адресу 8(%ebp), загружается в регистр %eax. Это повторно загружает указатель a, который был в %eax ранее
        movl    %edx, (%eax) ; Значение в %edx записывается по адресу, на который указывает %eax. Это производит обмен значениями между *a и *b.
        movl    12(%ebp), %eax ; Значение, находящееся по адресу 12(%ebp), загружается в регистр %eax. Это повторно загружает указатель b, который был в %eax ранее
        movl    -4(%ebp), %edx ; Значение в локальной переменной c, которая находится по адресу -4(%ebp), загружается в регистр %edx
        movl    %edx, (%eax) ; Значение в %edx записывается по адресу, на который указывает %eax. Это завершает обмен значениями между *a и *b
        nop
        leave ; Эта инструкция восстанавливает предыдущее значение %ebp из стека и перемещает %esp на это значение. Это используется перед выходом из функции.
        ret
.LC0:
        .string "%d "
main:
        leal    4(%esp), %ecx ; Эта инструкция вычисляет адрес 4(%esp) и помещает его в регистр %ecx. Обычно это используется для получения доступа к аргументам командной строки, переданным программе.
        andl    $-16, %esp ; Эта инструкция выравнивает указатель стека %esp по 16-байтной границе, что может быть необходимо для оптимизации производительности или совместимости с некоторыми инструкциями.
        pushl   -4(%ecx) ; Эта инструкция помещает значение, находящееся по адресу -4(%ecx), на стек. Вероятно, это какой-то аргумент или значение, связанное с командной строкой.
        pushl   %ebp ; Старое значение регистра %ebp сохраняется на стеке, чтобы можно было его восстановить перед выходом из функции.
        movl    %esp, %ebp ; Текущее значение регистра %esp копируется в регистр %ebp, устанавливая его в качестве базового указателя для локальных переменных и параметров функции.
        pushl   %ecx ;  Эта инструкция помещает значение регистра %ecx на стек.
        subl    $36, %esp ; Резервируется на стеке место для локальных переменных размером 36 байтов.
        movl    %ecx, %eax ; movl %ecx, %eax: Значение %ecx копируется в %eax.
        movl    4(%eax), %eax ; Загружается значение, находящееся по адресу 4(%eax), в %eax. Вероятно, это связано с аргументами командной строки.
        addl    $4, %eax
        movl    (%eax), %eax
        subl    $12, %esp ; Резервируется место на стеке для временных данных.
        pushl   %eax ; Значение в %eax помещается на стек. Вероятно, это значение аргумента командной строки, которое будет преобразовано в число.
        call    atoi
        addl    $16, %esp ; Освобождается место на стеке после вызова atoi.
        movl    %eax, -28(%ebp) ; Результат вызова atoi сохраняется в локальной переменной по адресу -28(%ebp).
        movl    -28(%ebp), %eax ;  Загружается значение n (хранящееся по адресу -28(%ebp)) в регистр %eax
        sall    $2, %eax ; Значение %eax сдвигается влево на 2 бита (эквивалентно умножению на 4). Это используется для вычисления размера массива в байтах.
        subl    $12, %esp ; Резервируется на стеке место для временных данных.
        pushl   %eax ; Значение в %eax (размер массива в байтах) помещается на стек.
        call    malloc
        addl    $16, %esp ; Освобождается место на стеке после вызова malloc.
        movl    %eax, -32(%ebp) ; Результат вызова malloc (адрес выделенной памяти) сохраняется в локальной переменной по адресу -32(%ebp). Это адрес начала массива.
        movl    $0, -12(%ebp) ; Значение 0 сохраняется в локальной переменной по адресу -12(%ebp). Это инициализация переменной i, используемой для цикла.
        jmp     .L3
.L4:
        movl    -28(%ebp), %eax ; Загружается значение n в регистр %eax.
        subl    -12(%ebp), %eax ; Из значения n вычитается текущее значение переменной i, и результат сохраняется в %eax. Это используется для ограничения внутреннего цикла.
        movl    %eax, %ecx ; Значение %eax копируется в %ecx, представляя верхний предел внутреннего цикла.
        movl    -12(%ebp), %eax ; Текущее значение i загружается в %eax.
        leal    0(,%eax,4), %edx ; Вычисляется смещение в байтах для доступа к элементу массива, и результат сохраняется в %edx.
        movl    -32(%ebp), %eax ; Загружается адрес начала массива в %eax.
        addl    %edx, %eax ; добавляется к %eax, чтобы получить адрес текущего элемента массива.
        movl    %ecx, %edx ; Значение %ecx копируется в %edx, представляя верхний предел внутреннего цикла.
        movl    %edx, (%eax) ; Значение в %edx (верхний предел) записывается в текущий элемент массива.
        addl    $1, -12(%ebp) ; величивается значение переменной i на 1.
.L3: ; Метка, обозначающая начало внешнего цикла.
        movl    -12(%ebp), %eax ; Загружается текущее значение переменной i в %eax.
        cmpl    -28(%ebp), %eax ; Сравнивается %eax (текущее значение i) с n (хранящимся по адресу -28(%ebp)).
        jb      .L4 ; Если i меньше n, то происходит переход к метке .L4, продолжая внутренний цикл.
        movl    $0, -16(%ebp) ; Значение 0 сохраняется в локальной переменной по адресу -16(%ebp). Это инициализация переменной j, используемой для внутреннего цикла сортировки пузырьком.
        jmp     .L5
.L9:
        movl    $0, -20(%ebp) ; Метка, обозначающая начало вложенного цикла, который используется для сравнения элементов внутри внутреннего цикла сортировки пузырьком.
        jmp     .L6
.L8:
        movl    -20(%ebp), %eax ; Метка, обозначающая начало блока сравнения элементов во внутреннем цикле.
        leal    0(,%eax,4), %edx ; Текущее значение переменной j загружается в %eax.
        movl    -32(%ebp), %eax ; 32(%ebp), %eax: Загружается адрес начала массива в %eax.
        addl    %edx, %eax ; Вычисляется адрес текущего элемента массива.
        movl    (%eax), %edx ; Значение текущего элемента сохраняется в %edx.
        movl    -20(%ebp), %eax ; Текущее значение переменной j загружается в %eax.
        addl    $1, %eax ; Значение %eax увеличивается на 1, представляя следующий элемент
        leal    0(,%eax,4), %ecx ; Вычисляется смещение в байтах для доступа к следующему элементу массива и сохраняется в %ecx.
        movl    -32(%ebp), %eax ;  Загружается адрес начала массива в %eax.
        addl    %ecx, %eax ; Вычисляется адрес следующего элемента массива.
        movl    (%eax), %eax ; Значение следующего элемента загружается в %eax.
        cmpl    %eax, %edx ; Значение текущего элемента сравнивается со следующим элементом.
        jle     .L7 ; Если текущий элемент не больше следующего, происходит переход к метке .L7
        movl    -20(%ebp), %eax ; Загружается текущее значение переменной j в регистр %eax
        addl    $1, %eax ; Увеличивается %eax на 1, представляя следующий элемент (первый из двух элементов, которые будут обменены).
        leal    0(,%eax,4), %edx ; Вычисляется смещение в байтах для доступа к текущему элементу массива (большему из двух) и сохраняется в %edx.
        movl    -32(%ebp), %eax ; Загружается адрес начала массива в %eax.
        addl    %eax, %edx ; Вычисляется адрес текущего элемента массива (большего из двух).
        movl    -20(%ebp), %eax ; Загружается текущее значение переменной j в %eax для доступа к меньшему элементу.
        leal    0(,%eax,4), %ecx ; Вычисляется смещение в байтах для доступа к меньшему элементу и сохраняется в %ecx.
        movl    -32(%ebp), %eax ; Загружается адрес начала массива в %eax.
        addl    %ecx, %eax ;  Вычисляется адрес меньшего элемента массива.
        subl    $8, %esp ; Резервируется место на стеке для вызова функции swap.
        pushl   %edx ; Адрес большего элемента (текущего элемента массива) помещается на стек в качестве первого аргумента для swap.
        pushl   %eax ; Адрес меньшего элемента помещается на стек в качестве второго аргумента для swap
        call    swap
        addl    $16, %esp ; Освобождает место на стеке после вызова swap
.L7:
        addl    $1, -20(%ebp) ; Значение переменной j увеличивается на 1.
.L6: ; Метка, обозначающая конец вложенного цикла, который используется для сравнения элементов внутри внутреннего цикла сортировки пузырьком.
        movl    -28(%ebp), %eax ; Загружается значение n в регистр %eax.
        subl    $1, %eax ; Из n вычитается 1, представляя верхний предел вложенного цикла.
        cmpl    %eax, -20(%ebp) ; Сравнивается текущее значение переменной j с верхним пределом вложенного цикла. jb .L8: Если j меньше верхнего предела вложенного цикла, происходит переход к метке .L8.
        jb      .L8
        addl    $1, -16(%ebp)
.L5: ;Метка, обозначающая конец внешнего цикла сортировки.
        movl    -28(%ebp), %eax ; Загружается значение n в регистр %eax.
        subl    $1, %eax ; Из n вычитается 1, представляя верхний предел внешнего цикла.d
        cmpl    %eax, -16(%ebp) ; Сравнивается текущее значение переменной i с верхним пределом внешнего цикла. jb .L9: Если i меньше верхнего предела внешнего цикла, 
        jb      .L9
        movl    $0, -24(%ebp)
        jmp     .L10
.L11: ; Метка, обозначающая начало блока вывода отсортированных значений.
        movl    -24(%ebp), %eax ; Загружается текущее значение переменной i в регистр %eax.
        leal    0(,%eax,4), %edx ; Вычисляется смещение в байтах для доступа к текущему элементу массива и сохраняется в %edx.
        movl    -32(%ebp), %eax ; Загружается адрес начала массива в %eax.
        addl    %edx, %eax ; Вычисляется адрес текущего элемента массива.
        movl    (%eax), %eax ; Значение текущего элемента массива загружается в %eax.
        subl    $8, %esp ;  Резервируется место на стеке для вызова функции printf.
        pushl   %eax ; Значение %eax помещается на стек как аргумент для printf.
        pushl   $.LC0
        call    printf
        addl    $16, %esp ; Освобождается место на стеке после вызова printf.
        addl    $1, -24(%ebp)
.L10:
        movl    -24(%ebp), %eax ; Загружается текущее значение переменной i в регистр %eax
        cmpl    -28(%ebp), %eax ; Сравнивается текущее значение i с n (хранящимся по адресу -28(%ebp)).
        jb      .L11
        movl    $0, %eax ; Значение 0 помещается в регистр %eax для возврата функции.
        movl    -4(%ebp), %ecx ; Старое значение указателя стека возвращается в регистр %ecx.
        leave ; Выполняется командой leave для восстановления предыдущего указателя стека %ebp и перемещения указателя стека %esp к нему.
        leal    -4(%ecx), %esp
        ret ; Функция завершает выполнение и возвращает управление вызывающей функции.

// sub - вычитание, mul - умножение imul - целочисленное умножение
// суффикс на конце - тип данных
// (,) - результат арифметической операции (сложения) 
// sal сдвиг влево на биты
// sltq расширенис eax до rax

// aex - регистр для временных данных, mov - присваивание(значние одного регистра присваивется в другой)
// add - сложение, adc - сложение с учетом переполнения на предыдущем сложении
// n() n - адрес в памяти относительно регистра в скобках 

// суффикс p в сопроцессоре гвоорит, что после операции нужно сдвинуть начало стека
// fld взять число по адресу и рагрузить на вершину стека

// векторные команды
// xmm регистр на 16 байт
// хранит вектор из целочисленных типов
// скалярное команды - взять два числа сложить их с другими двумя числами и получить два результата (как пример)
// в векторных регистрах числа занимают ровно столько, сколько им нужно, в сопроцессоре всегда 10 байт, но выше точность у сопроцессора
// суффикс s скалярная команда, в отличие от вектора может работать только с одним числом
// у x64 по дефолту используется xmm
// pd два дабла

// адреса
// 4() вот это адрес
// считывание с первого места, записывание на второе
// lea - вычисление адреса 0(,%rax,8) значение из rax умножается на 8 и записывается, не обращается в память
// .LC1 - обращение в память
// movsb - обращение в память, строковая команда, работает с памятью, адрес которых уже есть movsb => [rdi++] := [rsi++]
// n(x, y, z) вот эта штука берет, складывает два регистра, получает адрес, по адресу получает значение, если n и z нет, то n = 0, z = 1
// а не, нихера, нужно смотреть, что () эта штука именно делает
//
// флаги
// =======
//
// if/else
// cmovge условное присваивание ge меньше равно иль чето того
//
// stack
// когда кладем в стэк, тогда отнимаем 
// leave восстанавливаем положение стека
// ebp на высоких уровнях оптимизации используется как обычный регист, на низких, как...
; sub - выделение памяти на стеке

; Стек (или стек памяти) - это особая область памяти, используемая в ассемблере и многих других языках программирования для управления временными данными и вызова функций. 
; Стек представляет собой структуру данных, где данные хранятся и извлекаются в порядке "последний вошел - первый вышел" (LIFO - Last-In-First-Out). В ассемблере, управление стеком выполняется с использованием нескольких команд, включая push, pop, call, и ret. Давайте рассмотрим основные аспекты работы со стеком на уровне ассемблера:

; push и pop: Команды push и pop используются для помещения значений на вершину стека и извлечения значений с вершины стека соответственно. Например:

; assembly
; Copy code
; push eax   ; поместить значение регистра eax на вершину стека
; pop ebx    ; извлечь значение с вершины стека и сохранить его в регистре ebx
; Операции push и pop могут использоваться для сохранения и восстановления регистров и локальных переменных внутри функций.

; call и ret: Команды call и ret используются для вызова функций и возврата из функций. Команда call помещает текущий адрес возврата на стек и переходит к указанной функции, 
; а команда ret извлекает адрес возврата с вершины стека и возвращает управление обратно в вызывающую функцию.

; Указатель стека (%esp): Регистр %esp (Stack Pointer) указывает на текущую вершину стека. 
; При использовании команд push и pop, %esp автоматически обновляется. Вы можете использовать %esp для доступа к данным на стеке.

; Работа с параметрами функции: Параметры функции часто передаются через стек, и функция может получить к ним доступ, 
; обращаясь к адресам на стеке с использованием %esp и смещений. Например:

; Сохранение регистров: Перед выполнением функции часто требуется сохранить значения регистров на стеке, чтобы не потерять их. 
; Обычно это делается с использованием команд push и восстановление значений после завершения функции с использованием команд pop.


; %eax: Accumulator register — аккумулятор, применяется для хранения результатов промежуточных вычислений.
; %ebx: Base register — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти.
; %ecx: Counter register — счетчик, его неявно используют некоторые команды для организации циклов (см. loop).
; %edx: Data register — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода.
; %esp: Stack pointer register — указатель стека. Содержит адрес вершины стека.
; %ebp: Base pointer register — указатель базы кадра стека (англ. stack frame). Предназначен для организации произвольного доступа к данным внутри стека.
; %esi: Source index register — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник.
; %edi: Destination index register — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник.
;  смещение(база, индекс, множитель)



