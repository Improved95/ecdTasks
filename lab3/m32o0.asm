swap:
        pushl   %ebp ; Сохраняем текущее значение указателя стека на вершине стека
        movl    %esp, %ebp ; Копируем значение указателя стека в регистр ebp
        subl    $16, %esp ;  Резервируем место на стеке для локальных переменных
        movl    8(%ebp), %eax ; Копируем значение по адресу, на который указывает первый аргумент функции, в регистр eax
        movl    (%eax), %eax ; Копируем значение по адресу, на который указывает eax, в локальную переменную
        movl    %eax, -4(%ebp)
        movl    12(%ebp), %eax ; Копируем значение по адресу, на который указывает второй аргумент функции, в регистр eax
        movl    (%eax), %edx ; Копируем значение по адресу, на который указывает eax, в регистр edx 
        movl    8(%ebp), %eax ; Копируем значение по адресу, на который указывает первый аргумент функции, в регистр eax
        movl    %edx, (%eax) ; Копируем значение из локальной переменной c в память по адресу, на который указывает eax
        movl    12(%ebp), %eax ; Копируем значение по адресу, на который указывает второй аргумент функции, в регистр eaxы
        movl    -4(%ebp), %edx ; Копируем значение из локальной переменной c в память по адресу, на который указывает eax
        movl    %edx, (%eax)
        nop
        leave ; Освобождаем зарезервированное место на стеке
        ret
.LC0:
        .string "%d "
main:
        leal    4(%esp), %ecx ; сохраняем адрес второго аргумента функции (argv) в регистр ecx
        andl    $-16, %esp
        pushl   -4(%ecx)  ; сохраняем первый аргумент функции (argc) в стеке
        pushl   %ebp  ; сохраняем значение регистра ebp в стеке
        movl    %esp, %ebp   ; сохраняем текущий указатель стека в регистре ebp
        pushl   %ecx  ; сохраняем адрес второго аргумента функции (argv) в стеке
        subl    $36, %esp  ; выделяем на стеке 36 байт для локальных переменных
        movl    %ecx, %eax   ; сохраняем адрес второго аргумента функции (argv) в регистре eax
        movl    4(%eax), %eax ; Копируем значение по адресу, на который указывает eax + 4, в регистр eax
        addl    $4, %eax ; Добавляем 4 к значению в регистре eax и копируем получившееся значение в регистр eax 
        movl    (%eax), %eax ; Копируем значение по адресу, на который указывает eax, в регистр eax
        subl    $12, %esp ; Вычитаем 12 из указателя стека и заносим получившееся значение на вершину стека
        pushl   %eax 
        call    atoi ; Вызываем функцию atoi для преобразования строки в целое число, занося полученное значение в регистр eax
        addl    $16, %esp
        movl    %eax, -28(%ebp) ; Умножаем значение, на которое указывает -28(%ebp), на размер int (4 байта) и заносим получившееся значение на вершину стека
        movl    -28(%ebp), %eax
        sall    $2, %eax
        subl    $12, %esp
        pushl   %eax
        call    malloc ; Вызываем функцию malloc для выделения памяти под массив и заносим полученный указатель на вершину стека
        addl    $16, %esp
        movl    %eax, -32(%ebp)
        movl    $0, -12(%ebp) ; Заносим 0 в локальную переменную
        jmp     .L3
.L4:
        movl    -28(%ebp), %eax ; Копируем разницу между значением, на которое указывает -28(%ebp), и значением, на которое указывает -12(%ebp), в регистр eax
        subl    -12(%ebp), %eax 
        movl    %eax, %ecx
        movl    -12(%ebp), %eax ; Копируем значение, на которое указывает -12(%ebp), в регистр eax и умножаем на размер int (4 байта), после чего заносим полученное значение в регистр edx
        leal    0(,%eax,4), %edx 
        movl    -32(%ebp), %eax ; Копируем указатель на начало массива в регистр eax и добавляем к нему значение, на которое указывает edx, после чего заносим полученный адрес на вершину стека
        addl    %edx, %eax
        movl    %ecx, %edx
        movl    %edx, (%eax)
        addl    $1, -12(%ebp)
.L3:
        movl    -12(%ebp), %eax ; Копируем значение, на которое указывает -12(%ebp), в регистр eax
        cmpl    -28(%ebp), %eax ; Сравниваем значение в регистре eax с значением, на которое указывает -28(%ebp), и если оно меньше, то переходим на метку .L4
        jb      .L4
        movl    $0, -16(%ebp) ; Заносим 0 в локальную переменную -16(%ebp)
        jmp     .L5 ; Безусловный переход на метку .L5 (jmp .L5)
.L9:
        movl    $0, -20(%ebp) ; Заносим 0 в локальную переменную -20(%ebp)
        jmp     .L6 ; Безусловный переход на метку .L6 (jmp .L6)
.L8:
        movl    -20(%ebp), %eax ; Копируем значение, на которое указывает -20(%ebp), в регистр eax и умножаем на размер int (4 байта), после чего заносим полученное значение в регистр edx
        leal    0(,%eax,4), %edx
        movl    -32(%ebp), %eax ; Копируем указатель на начало массива в регистр eax и добавляем к нему значение, на которое указывает edx, после чего заносим полученный адрес в регистр eax
        addl    %edx, %eax
        movl    (%eax), %edx ;  Копируем значение, на которое указывает eax, в регистр edx
        movl    -20(%ebp), %eax ; Копируем значение, на которое указывает -20(%ebp), в регистр eax и добавляем 1, 
        addl    $1, %eax ; 
        leal    0(,%eax,4), %ecx ; после чего умножаем на размер int (4 байта), затем добавляем это значение к адресу начала массива и заносим полученный адрес в регистр ecx
        movl    -32(%ebp), %eax
        addl    %ecx, %eax 
        movl    (%eax), %eax ; Копируем значение, на которое указывает eax, в регистр eax
        cmpl    %eax, %edx ;  и сравниваем его с значением, на которое указывает edx. Если оно меньше или равно, то переходим на метку .L7
        jle     .L7
        movl    -20(%ebp), %eax ; Копируем значение, на которое указывает -20(%ebp), в регистр eax 
        leal    0(,%eax,4), %edx ; и добавляем 1, после чего умножаем на размер int (4 байта), 
        addl    $1, %eax 
        movl    -32(%ebp), %eax ; затем добавляем это значение к адресу начала массива 
        addl    %eax, %edx ; и заносим полученный адрес в регистр edx
        movl    -20(%ebp), %eax ; Копируем значение, на которое указывает -20(%ebp), в регистр eax
        leal    0(,%eax,4), %ecx ; и умножаем на размер int (4 байта)
        movl    -32(%ebp), %eax ; затем добавляем это значение к адресу начала массива
        addl    %ecx, %eax ; и заносим полученный адрес в регистр ecx
        subl    $8, %esp ; 
        pushl   %edx ; Заносим на вершину стека адреса двух элементов массива и вызываем функцию swap
        pushl   %eax
        call    swap
        addl    $16, %esp 
.L7:
        addl    $1, -20(%ebp) 
.L6:
        movl    -28(%ebp), %eax
        subl    $1, %eax
        cmpl    %eax, -20(%ebp)
        jb      .L8
        addl    $1, -16(%ebp)
.L5:
        movl    -28(%ebp), %eax
        subl    $1, %eax
        cmpl    %eax, -16(%ebp)
        jb      .L9
        movl    $0, -24(%ebp)
        jmp     .L10
.L11:
        movl    -24(%ebp), %eax
        leal    0(,%eax,4), %edx
        movl    -32(%ebp), %eax
        addl    %edx, %eax
        movl    (%eax), %eax
        subl    $8, %esp
        pushl   %eax
        pushl   $.LC0
        call    printf
        addl    $16, %esp
        addl    $1, -24(%ebp)
.L10:
        movl    -24(%ebp), %eax
        cmpl    -28(%ebp), %eax
        jb      .L11
        movl    $0, %eax
        movl    -4(%ebp), %ecx
        leave
        leal    -4(%ecx), %esp
        ret

// sub - вычитание, mul - умножение imul - целочисленное умножение
// суффикс на конце - тип данных
// (,) - результат арифметической операции (сложения) 
// sal сдвиг влево на биты
// sltq расширенис eax до rax

// aex - регистр для временных данных, mov - присваивание(значние одного регистра присваивется в другой)
// add - сложение, adc - сложение с учетом переполнения на предыдущем сложении
// n() n - адрес в памяти относительно регистра в скобках 

// суффикс p в сопроцессоре гвоорит, что после операции нужно сдвинуть начало стека
// fld взять число по адресу и рагрузить на вершину стека

// векторные команды
// xmm регистр на 16 байт
// хранит вектор из целочисленных типов
// скалярное команды - взять два числа сложить их с другими двумя числами и получить два результата (как пример)
// в векторных регистрах числа занимают ровно столько, сколько им нужно, в сопроцессоре всегда 10 байт, но выше точность у сопроцессора
// суффикс s скалярная команда, в отличие от вектора может работать только с одним числом
// у x64 по дефолту используется xmm
// pd два дабла

// адреса
// 4() вот это адрес
// считывание с первого места, записывание на второе
// lea - вычисление адреса 0(,%rax,8) значение из rax умножается на 8 и записывается, не обращается в память
// .LC1 - обращение в память
// movsb - обращение в память, строковая команда, работает с памятью, адрес которых уже есть movsb => [rdi++] := [rsi++]
// n(x, y, z) вот эта штука берет, складывает два регистра, получает адрес, по адресу получает значение, если n и z нет, то n = 0, z = 1
// а не, нихера, нужно смотреть, что () эта штука именно делает
//
// флаги
// =======
//
// if/else
// cmovge условное присваивание ge меньше равно иль чето того
//
// stack
// когда кладем в стэк, тогда отнимаем 
// leave восстанавливаем положение стека
// ebp на высоких уровнях оптимизации используется как обычный регист, на низких, как...
; sub - выделение памяти на стеке

; Стек (или стек памяти) - это особая область памяти, используемая в ассемблере и многих других языках программирования для управления временными данными и вызова функций. 
; Стек представляет собой структуру данных, где данные хранятся и извлекаются в порядке "последний вошел - первый вышел" (LIFO - Last-In-First-Out). В ассемблере, управление стеком выполняется с использованием нескольких команд, включая push, pop, call, и ret. Давайте рассмотрим основные аспекты работы со стеком на уровне ассемблера:

; push и pop: Команды push и pop используются для помещения значений на вершину стека и извлечения значений с вершины стека соответственно. Например:

; assembly
; Copy code
; push eax   ; поместить значение регистра eax на вершину стека
; pop ebx    ; извлечь значение с вершины стека и сохранить его в регистре ebx
; Операции push и pop могут использоваться для сохранения и восстановления регистров и локальных переменных внутри функций.

; call и ret: Команды call и ret используются для вызова функций и возврата из функций. Команда call помещает текущий адрес возврата на стек и переходит к указанной функции, 
; а команда ret извлекает адрес возврата с вершины стека и возвращает управление обратно в вызывающую функцию.

; Указатель стека (%esp): Регистр %esp (Stack Pointer) указывает на текущую вершину стека. 
; При использовании команд push и pop, %esp автоматически обновляется. Вы можете использовать %esp для доступа к данным на стеке.

; Работа с параметрами функции: Параметры функции часто передаются через стек, и функция может получить к ним доступ, 
; обращаясь к адресам на стеке с использованием %esp и смещений. Например:

; Сохранение регистров: Перед выполнением функции часто требуется сохранить значения регистров на стеке, чтобы не потерять их. 
; Обычно это делается с использованием команд push и восстановление значений после завершения функции с использованием команд pop.


; %eax: Accumulator register — аккумулятор, применяется для хранения результатов промежуточных вычислений.
; %ebx: Base register — базовый регистр, применяется для хранения адреса (указателя) на некоторый объект в памяти.
; %ecx: Counter register — счетчик, его неявно используют некоторые команды для организации циклов (см. loop).
; %edx: Data register — регистр данных, используется для хранения результатов промежуточных вычислений и ввода-вывода.
; %esp: Stack pointer register — указатель стека. Содержит адрес вершины стека.
; %ebp: Base pointer register — указатель базы кадра стека (англ. stack frame). Предназначен для организации произвольного доступа к данным внутри стека.
; %esi: Source index register — индекс источника, в цепочечных операциях содержит указатель на текущий элемент-источник.
; %edi: Destination index register — индекс приёмника, в цепочечных операциях содержит указатель на текущий элемент-приёмник.
;  смещение(база, индекс, множитель)



